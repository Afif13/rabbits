#!/bin/bash

#QEMU_SRCS_DIR
#QEMU_SRCS_DIR=../iss/sc-qemu/


# This will help us retrieve where we made the insertion
L_S="/* Annotation made by Rabbits */" # Label Start
L_E="/* -------------------------- */" # Label End

# This is the suffix for backup files in case the inserion goes wrong
B_F=".rabbits_annotation"

# ----------- Start CPU update -------------- #

#   Insert function in cpus.c to know when the CPU is changed
#   This happen in tcg_exec_all(void) within the for loop

    CPU_FUNCTION=rabbits_cpu_update

    # find the the function
    RES=$(grep -rn "${QEMU_SRCS_DIR}" --include=*.c -e "static void tcg_exec_all(void)" | tail -n 1)
    FILE_NAME=$(echo ${RES} | cut -d ":" -f1)
    NUM_LINE=$(echo ${RES} | cut -d ":" -f2)

    # Search the for loop
    NUM_LINE_ADD=`expr "${NUM_LINE}" + 20`
    NUM_LINE_SUP=$(head -n ${NUM_LINE_ADD} ${FILE_NAME} | tail -n 20 | grep -n -e "for" | cut -d ":" -f1)

    NUM_LINE=`expr "${NUM_LINE}" + "${NUM_LINE_SUP}" + 1` # Where to insert our call
    sed -i$B_F "${NUM_LINE}i\    ${L_S}\n\
    ${CPU_FUNCTION}();\n\
    ${L_E}" $FILE_NAME

# ----------- End CPU update -------------- #


#   We will use generic Helper to get the necessary values (for now : insn and pc)
#   After that we will do the necessay treatement (icache call, cycle calculating, etc)
#   like that we will have almost the same manner to do annotation in all architectures

# -------- Insert annotation in ARM architecture -------- #

#   We are intrested by the function cpu_ldx_code (x = {sign}{size}, refer to cpu_ldst.h)
#   This function is called within the generate_intermediate_code
#   to load the INSTRUCTION with the PC. We do our insertion after this call.

    ARCH=arm

    HELPER_FUNCTION=${ARCH}_rabbits_call # The helper function in Qemu side
    CALL_FUNCTION=rabbits_${ARCH}_call # The function in the rabbits side
                                       # the one we have to implement

    # The header of the helper function
    FILE_NAME=$(find "${QEMU_SRCS_DIR}" -name "helper.h" | grep -e "${ARCH}")
    sed -i$B_F "1i\ ${L_S}\nDEF_HELPER_2(${HELPER_FUNCTION},void,i32,i32)\n${L_E}" $FILE_NAME

    # The implementation of the helper function
    FILE_NAME=$(find "${QEMU_SRCS_DIR}" -name "op_helper.c" | grep -e "${ARCH}")
    echo -n -e "\n$L_S\nvoid HELPER($HELPER_FUNCTION)(uint32_t pc, uint32_t insn)\n{
    $CALL_FUNCTION(pc,insn);\n}\n$L_E" >> ${FILE_NAME}


    # find the call of cpu_ldx_code (here we search for arm_ldx_code)
    # TODO: try to find a more generic manner that can fit all the architecture
    # This a very bad hard coded insertion !! we need to find a better way
    FILE_NAME="${QEMU_SRCS_DIR}/target-${ARCH}/translate.c"
    RES=$(grep  -n "${FILE_NAME}" -e "arm_ldl_code(" | tail -n 1)
    NUM_LINE=$(echo ${RES} | cut -d ":" -f1)
    ARG=$(echo ${RES} | cut -d "," -f2) # We get the second argument which is the PC
    ARG1=insn # we get the result which is the INSTRUCTION (i know it's bad ...)
    TMP_ARG=pc_tmp_rabbits # A temporary TCG variable to use for pc
    TMP_ARG1=insn_tmp_rabbits # A temporary TCG variable to use for insn

    NUM_LINE=`expr "${NUM_LINE}" + 1` # Where to insert our call
    sed -i$B_F "${NUM_LINE}i\    ${L_S}\n\
    TCGv    ${TMP_ARG} = tcg_temp_new();\n\
    TCGv    ${TMP_ARG1} = tcg_temp_new();\n\
    tcg_gen_movi_i32(${TMP_ARG},(uint32_t)${ARG});\n\
    tcg_gen_movi_i32(${TMP_ARG1},(uint32_t)${ARG1});\n\
    gen_helper_${HELPER_FUNCTION}(${TMP_ARG},${TMP_ARG1});\n\
    tcg_temp_free (${TMP_ARG});\n\
    tcg_temp_free (${TMP_ARG1});\n\
    ${L_E}" $FILE_NAME


# -------- End Annotation insertion in ARM --------------- #


# -------- Insert annotation in XX architecture -------- #


# -------- End Annotation insertion in XX --------------- #



# ------ Insert Dcache call in all the architecture ----- #

# In reality we will not do Dcache call here but will modify the memory calls

# We are interested with the Helpers defined in softmmu_template.h
# This helper are use by each architecture to perform memroy call

# The helpers call are stored in a constant array under tcg-target.c
# qemu_ld_helpers and qemu_st_helpers
# We will modify this array in order to redirect the helpers


LD_HELPER_S="extern tcg_target_ulong helper_"
LD_HELPER_E="_mmu_rabbits(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr);"

LD_HELPER=$LD_HELPER_S"ret_ldub"${LD_HELPER_E}"\n"\
$LD_HELPER_S"le_lduw"$LD_HELPER_E"\n"\
$LD_HELPER_S"be_lduw"$LD_HELPER_E"\n"\
$LD_HELPER_S"le_ldul"$LD_HELPER_E"\n"\
$LD_HELPER_S"be_ldul"$LD_HELPER_E"\n"\
$LD_HELPER_S"le_ldq"$LD_HELPER_E"\n"\
$LD_HELPER_S"be_ldq"$LD_HELPER_E"\n"\
$LD_HELPER_S"ret_ldsb"$LD_HELPER_E"\n"\
$LD_HELPER_S"le_ldsw"$LD_HELPER_E"\n"\
$LD_HELPER_S"le_ldsl"$LD_HELPER_E"\n"\
$LD_HELPER_S"be_ldsw"$LD_HELPER_E"\n"\
$LD_HELPER_S"be_ldsl"$LD_HELPER_E"\n"

ST_HELPER_S="extern void helper_"
ST_HELPER_E1="_mmu_rabbits(CPUArchState *env, target_ulong addr, "
ST_HELPER_E2=", TCGMemOpIdx oi, uintptr_t retaddr);"

ST_HELPER=$ST_HELPER_S"ret_stb"$ST_HELPER_E1"uint8_t val"$ST_HELPER_E2"\n"\
$ST_HELPER_S"le_stw"$ST_HELPER_E1"uint16_t val"$ST_HELPER_E2"\n"\
$ST_HELPER_S"be_stw"$ST_HELPER_E1"uint16_t val"$ST_HELPER_E2"\n"\
$ST_HELPER_S"le_stl"$ST_HELPER_E1"uint32_t val"$ST_HELPER_E2"\n"\
$ST_HELPER_S"be_stl"$ST_HELPER_E1"uint32_t val"$ST_HELPER_E2"\n"\
$ST_HELPER_S"le_stq"$ST_HELPER_E1"uint64_t val"$ST_HELPER_E2"\n"\
$ST_HELPER_S"be_stq"$ST_HELPER_E1"uint64_t val"$ST_HELPER_E2"\n"


    # Insert our call in all the Architecture

    for ARCH in 'i386' 'arm' 'mips' # We can add the architecture we want
    do

    # Find the Array of load helper
    RES=$(grep --include=*.c -rn "${QEMU_SRCS_DIR}/tcg/${ARCH}" -e "const qemu_ld_helpers" | tail -n 1)
    FILE_NAME=$(echo ${RES} | cut -d ":" -f1)
    NUM_LINE=$(echo ${RES} | cut -d ":" -f2)


    # We get the content of the array to avoid having different content (a bit hardcoded ...)
    INC=`expr "${NUM_LINE}" + 1`
    CONTENT=$(sed -n "${INC}p" $FILE_NAME | cut -d"," -f1)
    NEW_CONTENT=""
    while test "$CONTENT" != "};"
    do
        if [ ! -z "$CONTENT" ]; then # This for Arm that are using empty lines !!!
            CONTENT+="_rabbits,\n"
        fi
        NEW_CONTENT+=$CONTENT
        INC=`expr "${INC}" + 1`
        CONTENT=$(sed -n "${INC}p" $FILE_NAME | cut -d"," -f1)
    done

    #We change it by our own content
    sed -i$B_F "${INC}i\ */" $FILE_NAME
    NUM_LINE=`expr "${NUM_LINE}" + 1`
    sed -i$B_F "${NUM_LINE}i\ ${NEW_CONTENT}/*" $FILE_NAME

    # We insert the helpers headers to avoid errors
    NUM_LINE=`expr "${NUM_LINE}" - 1`
    sed -i$B_F "${NUM_LINE}i\ ${L_S}\n${LD_HELPER}\n${L_E}" $FILE_NAME

    # We do the same process with store helper
    RES=$(grep --include=*.c -rn "${QEMU_SRCS_DIR}/tcg/${ARCH}" -e "const qemu_st_helpers" | tail -n 1)
    FILE_NAME=$(echo ${RES} | cut -d ":" -f1)
    NUM_LINE=$(echo ${RES} | cut -d ":" -f2)


    # We get the content of the array to avoid having different content (a bit hardcoded ...)
    INC=`expr "${NUM_LINE}" + 1`
    CONTENT=$(sed -n "${INC}p" $FILE_NAME | cut -d"," -f1)
    NEW_CONTENT=""
    while test "$CONTENT" != "};"
    do
        if [ ! -z "$CONTENT" ]; then # This for Arm that are using empty lines !!!
            CONTENT+="_rabbits,\n"
        fi
        NEW_CONTENT+=$CONTENT
        INC=`expr "${INC}" + 1`
        CONTENT=$(sed -n "${INC}p" $FILE_NAME | cut -d"," -f1)
    done

    #We change it by our own content
    sed -i$B_F "${INC}i\ */" $FILE_NAME
    NUM_LINE=`expr "${NUM_LINE}" + 1`
    sed -i$B_F "${NUM_LINE}i\ ${NEW_CONTENT}/*" $FILE_NAME

    # We insert the helpers headers to avoid errors
    NUM_LINE=`expr "${NUM_LINE}" - 1`
    sed -i$B_F "${NUM_LINE}i\ ${L_S}\n${ST_HELPER}\n${L_E}" $FILE_NAME
    done

# ------ End Dcache call Insertion ----- #
