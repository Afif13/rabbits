#!/bin/bash

#QEMU_SRCS_DIR
#QEMU_SRCS_DIR=../iss/sc-qemu/


# This will help us retrieve where we made the insertion
L_S="/* Annotation made by Rabbits */" # Label Start
L_E="/* -------------------------- */" # Label End

# This is the suffix for backup files in case the inserion goes wrong
B_F=".rabbits_annotation"

# ----------- Start CPU update -------------- #

#   Insert function in cpus.c to know when the CPU is changed
#   This happen in tcg_exec_all(void) within the for loop

    CPU_FUNCTION=rabbits_cpu_update

    # find the the function
    RES=$(grep -rn "${QEMU_SRCS_DIR}" --include=*.c -e "static void tcg_exec_all(void)" | tail -n 1)
    FILE_NAME=$(echo ${RES} | cut -d ":" -f1)
    NUM_LINE=$(echo ${RES} | cut -d ":" -f2)

    # Search the for loop
    NUM_LINE_ADD=`expr "${NUM_LINE}" + 20`
    NUM_LINE_SUP=$(head -n ${NUM_LINE_ADD} ${FILE_NAME} | tail -n 20 | grep -n -e "for" | cut -d ":" -f1)

    NUM_LINE=`expr "${NUM_LINE}" + "${NUM_LINE_SUP}" + 1` # Where to insert our call
    sed -i$B_F "${NUM_LINE}i\    ${L_S}\n\
    ${CPU_FUNCTION}();\n\
    ${L_E}" $FILE_NAME

# ----------- End CPU update -------------- #


# -------- Insert annotation in ARM architecture -------- #

#   We are intrested by the functions disas_xx_insn (xx = arm or thumb)
#   This two functions are called within the while loop of gen_intermediate_code
#   After that we do our own decoding to check the type of instruction and see if we add extra cycle


    # Add annotation to the disas_arm_insn

    XX=arm

    ANNOTATE_FUNCTION=rabbits_annotate_${XX}_insn

    # find the function
    RES=$(grep --include=*.c -rn "${QEMU_SRCS_DIR}/target-arm" -e "static void disas_${XX}_insn" | tail -n 1)
    FILE_NAME=$(echo ${RES} | cut -d ":" -f1)
    NUM_LINE=$(echo ${RES} | cut -d ":" -f2)

    #get the last argument of the function
    P=$(sed -n ${NUM_LINE}p ${FILE_NAME} | rev | cut -d "," -f1 | rev)
    #get only the parameter name
    NAME_P=$(echo ${P} | rev | cut -d " " -f1 | rev)

    NUM_LINE=`expr "${NUM_LINE}" + 2` # Where to insert our call
    sed -i$B_F "${NUM_LINE}i\    ${L_S}\n\
    ${ANNOTATE_FUNCTION}(${NAME_P};\n\
    ${L_E}" $FILE_NAME

    # Add annotation to the disas_thumb_insn

    XX=thumb

    ANNOTATE_FUNCTION=rabbits_annotate_${XX}_insn

    # find the function
    RES=$(grep --include=*.c -rn "${QEMU_SRCS_DIR}/target-arm" -e "static void disas_${XX}_insn" | tail -n 1)
    FILE_NAME=$(echo ${RES} | cut -d ":" -f1)
    NUM_LINE=$(echo ${RES} | cut -d ":" -f2)


    # Search the for the insn argument.
    # TODO : Try to find a non complicated way to make this !
    NUM_LINE_ADD=`expr "${NUM_LINE}" + 20`
    NUM_LINE_SUP=$(head -n ${NUM_LINE_ADD} ${FILE_NAME} | tail -n 20 | grep -n -e "insn = " | cut -d ":" -f1)


    NUM_LINE=`expr "${NUM_LINE}" + "${NUM_LINE_SUP}" + 1` #where to insert our call
    sed -i$B_F "${NUM_LINE}i\    ${L_S}\n\
    ${ANNOTATE_FUNCTION}(insn);\n\
    ${L_E}" $FILE_NAME

# -------- End Annotation insertion in ARM --------------- #


# -------- Insert annotation in XX architecture -------- #


# -------- End Annotation insertion in XX --------------- #



# ------ Insert Icache call in all the architecture ----- #

#   We are intrested by the function cpu_ldx_code (x = {sign}{size}, refer to cpu_ldst.h)
#   This function is called within the generate_intermediate_code
#   to load the instruction from the current pc. We do our insertion after this call.
#   TODO : try to find a better way to get the pc

#   Since we are going to do a function call into the generated code we are obliged to
#   work with the helper

ICACHE_HELPER=icache_call
ICACHE_FUNCTION=rabbits_${ICACHE_HELPER}

    # Add icache call for ARM

    ARCH=arm

    # The header of the helper function
    FILE_NAME=$(find "${QEMU_SRCS_DIR}" -name "helper.h" | grep -e "${ARCH}")
    sed -i$B_F "1i\ ${L_S}\nDEF_HELPER_1(${ICACHE_HELPER},void,i32)\n${L_E}" $FILE_NAME

    #mv rabbits_file_${ARCH}_icache ${FILE_NAME}

    # The implementation of the helper function
    FILE_NAME=$(find "${QEMU_SRCS_DIR}" -name "op_helper.c" | grep -e "${ARCH}")
    echo -n -e "\n$L_S\nvoid HELPER($ICACHE_HELPER)(uint32_t addr)\n{
    $ICACHE_FUNCTION(addr);\n}\n$L_E" >> ${FILE_NAME}

    # find the call of cpu_ldx_code (here we search for arm_ldx_code)
    # TODO: try to find a more generic manner that can fit all the architecture
    # This a very bad hard coded insertion !! we need to find a better way
    FILE_NAME="${QEMU_SRCS_DIR}/target-${ARCH}/translate.c"
    RES=$(grep  -n "${FILE_NAME}" -e "arm_ldl_code(" | tail -n 1)
    NUM_LINE=$(echo ${RES} | cut -d ":" -f1)
    ARG=$(echo ${RES} | cut -d "," -f2) # We get the second argument which is the PC
    TMP_ARG=pc_tmp_rabbits # A temporary TCG variable to use

    NUM_LINE=`expr "${NUM_LINE}" + 1` # Where to insert our call
    sed -i$B_F "${NUM_LINE}i\    ${L_S}\n\
    TCGv    ${TMP_ARG} = tcg_temp_new();\n\
    tcg_gen_movi_i32(${TMP_ARG},(uint32_t)${ARG});\n\
    gen_helper_${ICACHE_HELPER}(${TMP_ARG});\n\
    tcg_temp_free (${TMP_ARG});\n\
    ${L_E}" $FILE_NAME


# ------ End Icache call Insertion ----- #


# ------ Insert Dcache call in all the architecture ----- #

# We are interested with the Helpers defined in softmmu_template.h
# This helper are use by each architecture in the TCG Back end

# The helpers call are stored in a constant array under tcg-target.c
# qemu_ld_helpers and qemu_st_helpers
# We will modify this array to put our helper calls

LD_HELPER_S="extern tcg_target_ulong helper_"
LD_HELPER_E="_mmu_rabbits(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi, uintptr_t retaddr);"

LD_HELPER=$LD_HELPER_S"ret_ldub"${LD_HELPER_E}"\n"\
$LD_HELPER_S"le_lduw"$LD_HELPER_E"\n"\
$LD_HELPER_S"be_lduw"$LD_HELPER_E"\n"\
$LD_HELPER_S"le_ldul"$LD_HELPER_E"\n"\
$LD_HELPER_S"be_ldul"$LD_HELPER_E"\n"\
$LD_HELPER_S"le_ldq"$LD_HELPER_E"\n"\
$LD_HELPER_S"be_ldq"$LD_HELPER_E"\n"\
$LD_HELPER_S"ret_ldsb"$LD_HELPER_E"\n"\
$LD_HELPER_S"le_ldsw"$LD_HELPER_E"\n"\
$LD_HELPER_S"le_ldsl"$LD_HELPER_E"\n"\
$LD_HELPER_S"be_ldsw"$LD_HELPER_E"\n"\
$LD_HELPER_S"be_ldsl"$LD_HELPER_E"\n"

ST_HELPER_S="extern void helper_"
ST_HELPER_E1="_mmu_rabbits(CPUArchState *env, target_ulong addr, "
ST_HELPER_E2=", TCGMemOpIdx oi, uintptr_t retaddr);"

ST_HELPER=$ST_HELPER_S"ret_stb"$ST_HELPER_E1"uint8_t val"$ST_HELPER_E2"\n"\
$ST_HELPER_S"le_stw"$ST_HELPER_E1"uint16_t val"$ST_HELPER_E2"\n"\
$ST_HELPER_S"be_stw"$ST_HELPER_E1"uint16_t val"$ST_HELPER_E2"\n"\
$ST_HELPER_S"le_stl"$ST_HELPER_E1"uint32_t val"$ST_HELPER_E2"\n"\
$ST_HELPER_S"be_stl"$ST_HELPER_E1"uint32_t val"$ST_HELPER_E2"\n"\
$ST_HELPER_S"le_stq"$ST_HELPER_E1"uint64_t val"$ST_HELPER_E2"\n"\
$ST_HELPER_S"be_stq"$ST_HELPER_E1"uint64_t val"$ST_HELPER_E2"\n"


    # Insert our call in all the Architecture

    for ARCH in 'i386' 'arm' 'mips' # We can add the architecture we want
    do
    # Find the Array of load helper

    RES=$(grep --include=*.c -rn "${QEMU_SRCS_DIR}/tcg/${ARCH}" -e "const qemu_ld_helpers" | tail -n 1)
    FILE_NAME=$(echo ${RES} | cut -d ":" -f1)
    NUM_LINE=$(echo ${RES} | cut -d ":" -f2)


    # We get the content of the array to avoid having different content (a bit hardcoded ...)
    INC=`expr "${NUM_LINE}" + 1`
    CONTENT=$(sed -n "${INC}p" $FILE_NAME | cut -d"," -f1)
    NEW_CONTENT=""
    while test "$CONTENT" != "};"
    do
        if [ ! -z "$CONTENT" ]; then # This for Arm that are using empty lines !!!
            CONTENT+="_rabbits,\n"
        fi
        NEW_CONTENT+=$CONTENT
        INC=`expr "${INC}" + 1`
        CONTENT=$(sed -n "${INC}p" $FILE_NAME | cut -d"," -f1)
    done

    #We change it by our own content
    sed -i$B_F "${INC}i\ */" $FILE_NAME
    NUM_LINE=`expr "${NUM_LINE}" + 1`
    sed -i$B_F "${NUM_LINE}i\ ${NEW_CONTENT}/*" $FILE_NAME

    # We insert the helpers headers to avoid errors
    NUM_LINE=`expr "${NUM_LINE}" - 1`
    sed -i$B_F "${NUM_LINE}i\ ${L_S}\n${LD_HELPER}\n${L_E}" $FILE_NAME

    # We do the same process with store helper
    RES=$(grep --include=*.c -rn "${QEMU_SRCS_DIR}/tcg/${ARCH}" -e "const qemu_st_helpers" | tail -n 1)
    FILE_NAME=$(echo ${RES} | cut -d ":" -f1)
    NUM_LINE=$(echo ${RES} | cut -d ":" -f2)


    # We get the content of the array to avoid having different content (a bit hardcoded ...)
    INC=`expr "${NUM_LINE}" + 1`
    CONTENT=$(sed -n "${INC}p" $FILE_NAME | cut -d"," -f1)
    NEW_CONTENT=""
    while test "$CONTENT" != "};"
    do
        if [ ! -z "$CONTENT" ]; then # This for Arm that are using empty lines !!!
            CONTENT+="_rabbits,\n"
        fi
        NEW_CONTENT+=$CONTENT
        INC=`expr "${INC}" + 1`
        CONTENT=$(sed -n "${INC}p" $FILE_NAME | cut -d"," -f1)
    done

    #We change it by our own content
    sed -i$B_F "${INC}i\ */" $FILE_NAME
    NUM_LINE=`expr "${NUM_LINE}" + 1`
    sed -i$B_F "${NUM_LINE}i\ ${NEW_CONTENT}/*" $FILE_NAME

    # We insert the helpers headers to avoid errors
    NUM_LINE=`expr "${NUM_LINE}" - 1`
    sed -i$B_F "${NUM_LINE}i\ ${L_S}\n${ST_HELPER}\n${L_E}" $FILE_NAME
    done

# ------ End Dcache call Insertion ----- #
