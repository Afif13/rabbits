#!/bin/bash

log_info() {
  echo $@ | tee -a $CONFIG_LOG
}

log_error() {
  echo ERROR: $@ | tee -a $CONFIG_LOG >&2
}

print_log_banner() {
  printf '# %s\n' "Rabbits configure log generated on $(date)"
  printf "# %s '%s'\n" 'Configured with' "$*"
}

# Check command existence
has() {
  type "$1" >/dev/null 2>&1
}

# Check given value in $1 is "yes"
# Print $2 and exit 1 otherwise
check_yes() {
  if test x"$1" != x"yes"; then
    log_error $2
    exit 1
  fi
}

# Try to compile temporary C source
compile_tmpc() {
  $CC $CFLAGS -o "$TMP_O" -c "$TMP_C" >/dev/null 2>&1
}

# Check if $1 is defined in a C program
check_define() {
  cat >"$TMP_C" <<EOF
#if ! defined($1)
#error $1 not defined
#endif
int main(void) { return 0; }
EOF
  compile_tmpc
}

# Print variables name and value
put_vars() {
  local value
  for v in $@; do
    eval value=\$$v
    printf "%s=%s\n" "$v" "$value"
  done
}

# Generate a config.h file
#  Replace 'y' with '1'
#  Don't emit the variable if it equals to 'n'
conf_h_gen() {
  local value

  printf '%s\n' "/* Autogenerated by configure. Do not modify */"

  for v in $@; do
    eval value=\$$v

    case "$value" in
      "y") value="1";;
      "n") continue;;
      *) value="\"$value\"";;
    esac

    printf "#define %s %s\n" "$v" "$value"
  done
}

# Append $2 to variable named by $1
append_to_var() {
  local cur_val=

  eval cur_val=\"\$$1\"

  if test x"$cur_val" == x""; then
    eval $1="$2"
  else
    eval $1=\"\$$1 $2\"
  fi
}

# Return the absolute path corresponding to the relative one given in first parameter
absolutize() {
  (
    cd "$1"
    pwd
  )
}

# Check if a directory is empty
dir_is_empty() {
  (
    ret=1
    cd "$1"
    shopt -s nullglob dotglob
    files=(*)
    (( ${#files[*]} )) || ret=0
    shopt -u nullglob dotglob
    exit $ret
  )
}

# Try to guess the OS we are running on and return it into $target_os
guess_os() {
  if check_define __linux__ ; then
    target_os="Linux"
  else
    target_os=$(uname -s)
  fi
}

# Try to guess the architecture we are running on and return it into $arch
guess_arch() {
  if check_define __x86_64__ ; then
    arch="x86_64"
  elif check_define __i386__ ; then
    arch="i386"
  else
    arch=$(uname -m)
  fi
}

# Find all the platforms.
find_platforms() {
  local r p iss

  for r in "${REPOS[@]}"; do
    find "$SRCS_DIR"/"$r"/"$PLATFORM_CONF_DIR" -name '*.mak' | while read p ; do
      iss=$(grep PLATFORM_ARCH "$p" | cut -f2 -d=)
      printf '%s|%s|%s\n' "$(basename "$p" .mak)" "$(absolutize "$SRCS_DIR"/"$r")" "$iss"
    done
  done | sort
}

# Select only enabled platforms in $platforms_list
select_platforms() {
  local p r iss sta all

  all="false"
  [[ -z "$1" ]] && all="true"

  while IFS='|' read p r iss ; do
    if $all || printf '%s' "$1" | grep -q "^$p$\|^$p,\|,$p,\|,$p$" ; then
      sta="enabled"
    else
      sta="disabled"
    fi
    printf '%s|%s|%s|%s\n' "$p" "$r" "$iss" "$sta"
  done

  return 0
}

# Print the platforms list
list_platforms() {
  local p rest
  while IFS='|' read p rest ; do
    printf '%s ' "$p"
  done
}

# Print the enabled platforms list
list_enabled_platforms() {
  local p r iss sta
  while IFS='|' read p r iss sta; do
    [[ $sta = "enabled" ]] && printf '%s ' "$p"
  done
}

# List the enabled iss
list_iss() {
  local p r iss sta

  while IFS='|' read p r iss sta; do
    [[ $sta = "enabled" ]] && printf '%s\n' "$iss"
  done | sort | uniq

}

# Create dythe target list for QEMU configure script
format_target_list() {
  list_iss | awk '{ printf("%s%s-softmmu", prefix, $0); prefix="," }'
}

# Generate compilation flags for each repository
generate_repos_cflags() {
  local p r iss sta

  while IFS='|' read p r iss sta; do
    printf '%s%s/src\n' '-I' $r
  done | sort | uniq | tr '\n' ' '

}

list_repos_srcs() {
  for r in "${REPOS[@]}"; do
    printf '%s ' "$(absolutize "$SRCS_DIR"/"$r")"
  done
}

# vim: ts=2 sw=2 sts=0 expandtab
